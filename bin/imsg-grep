#!/usr/bin/env ruby
# frozen_string_literal: true
# Search and filter iMessage database entries with regex patterns, date ranges, and participant filters

require "bundler/setup"

require "date"
require "json"
require "sqlite3"
require "rainbow"
require "strop"

require_relative "../lib/grep/date"
require_relative "../lib/grep/strop_utils"
require_relative "../lib/dev/print_query"

require_relative "../lib/messages"


include Strop::Exports

@case = :smart
@mode = :regexp
@conditions = Hash.new{ |h,k| h[k] = [] }
@utc = false


################################################################################
### parse helpers ##############################################################
################################################################################

def parse_date(str, utc = @utc)
  DateArg.parse(str, utc)
rescue DateArg::Error
  raise OptionError, "Invalid date #{str}; Use YYYY-MM-DD, or relative dates: 1y4m2d; See --help for details"
end

def date_cmp(op, dt)
  case [dt, @utc]
  in Date, true  then "utc_date   #{op} '#{dt.strftime('%Y-%m-%d')}'"
  in Date, false then "local_date #{op} '#{dt.strftime('%Y-%m-%d')}'"
  in Time, _     then "unix_time  #{op} #{dt.to_i}"
  end
end

def parse_p_int(str)
  Integer(str).tap{ raise ArgumentError unless it > 0 }
rescue ArgumentError
  raise OptionError, "#{str} not a positive integer"
end

def parse_capture(str)
  case str
  when nil            then '\0'
  when /\A\d(,\d)*\z/ then str.gsub(/(?=\d)/, ?\\).gsub(",", " ") # 1 or 1,2; "1,2" => "$1 $2"; 0 == $&
  when /\$[&\d]/      then str.gsub(?$, ?\\)
  else raise OptionError, "Invalid capture format: #{str}. Use '1,2' or '$1 $2'"
  end
end

# LIKE is too much of a mess. ASCII-insensitive, only sensitive option is GLOB. Regexp everything at some perf cost.
def mk_regexp(pattern)
  case_ = @case
  case_ = /\p{Upper}/ =~ pattern ? :sensitive : :ignore if case_ == :smart
  pattern = Regexp.escape(pattern) if @mode == :literal
  flags = [Regexp::IGNORECASE] if case_ == :ignore
  Regexp.new(pattern, *flags)
rescue RegexpError => e
  raise OptionError, "Invalid regular expression (#{pattern}): #{e.message}"
end

def add_cond(key, value)
  @conditions[key] << value
end

################################################################################
### begin option parsing #######################################################
################################################################################
begin
  HELP = DATA.read.gsub("PROG", File.basename($0))
  optlist = Strop.parse_help HELP
  optlist << Optdecl[:D, :debug]
  optlist << Optdecl[:opts]
  result = Strop.parse optlist
  # result = Strop.parse! HELP
  # puts optlist
  # puts optlist.to_s(:case)
  # puts result.to_s

  capture_opts = %w[ capture ]
  text_opts    = %w[ message-only one-line ]
  json_opts    = %w[ json payload ]
  result.exclusive json_opts, text_opts
  result.exclusive json_opts, capture_opts
  result.exclusive "sent", "received"

  for opt in result
    case opt
    in label: "since", value:    then add_cond :since, parse_date(value)
    in label: "until", value:    then add_cond :until, parse_date(value)
    in label: "to", value:       then add_cond :to, mk_regexp(value)
    in label: "from", value:     then add_cond :from, mk_regexp(value)
    in label: "with", value:     then add_cond :with, mk_regexp(value)
    in label: "chat", value:     then add_cond :chat, mk_regexp(value)
    in label: "smart-case"       then @case = :smart
    in label: "ignore-case"      then @case = :ignore
    in label: "no-ignore-case"   then @case = :sensitive
    in label: "literal"          then @mode = :literal
    in label: "regexp"           then @mode = :regexp
    in label: "max", value:      then @limit = parse_p_int(value); @allow_all = true
    in label: "all"              then @allow_all = true
    in label: "sent"             then add_cond :from_me, true
    in label: "received"         then add_cond :from_me, false
    in label: "links", value:nil then add_cond :links, true
    in label: "links", value:    then add_cond :links, value
    in label: "youtube"          then add_cond :links, :youtube
    in label: "soundcloud"       then add_cond :links, :soundcloud
    in label: "twitter"          then add_cond :links, :twitter
    in label: "capture", value:  then @capture = parse_capture(value)
    in label: "message-only"     then @msg_only = true
    in label: "one-line"         then @one_line = true
    in label: "json"             then @json = true
    in label: "payload"          then @json = true, @payload = true
    in label: "reverse"          then @reverse = true
    in label: "color"            then Rainbow.enabled = opt.yes?
    in label: "utc"              then @utc = true
    in label: "reset"            then Messages.reset_cache; exit if (result.map(&:label) - ["reset"]).empty?
    in label: "help"             then puts HELP; exit
    in label: "debug"            then @debug = true
    # in label: "opts"             then puts "Remaining options: " + ((?0..?z).to_a.grep(/\w/) - optlist.flat_map{ it.names.reject{it[1]} }).join(", ")
    # in label: "opts"             then puts (?0..?z).to_a.grep(/\w/).map{ it + ": " + (optlist[it]&.label || "") }
    in label: "opts"             then puts (?0..?z).to_a.grep(/\w/).map{ Rainbow(it).send(optlist[it]&.label ? :red : :bright) }.join(" "); exit
    in arg:                      then add_cond :message, mk_regexp(arg)
    in Sep
    end
    # o.bool   "-D", "--debug ID",         "Print way too much abt msg with id"
    # -q, silent, 0 or 1 exit if match
  end

################################################################################
### checking conflicting options ###############################################
################################################################################

  d0, d1 = @conditions.values_at(:since, :until).map{it.uniq.sort}
  $stderr.puts "Warning: multiple since dates given. Most recent wins"  if d0.size > 1
  $stderr.puts "Warning: multiple until dates given. Least recent wins" if d1.size > 1
  d0 = d0.last
  d1 = d1.first
  # Time+Date would fail compare below, so we lose precision to make it work
  # these values are not used other than for this check
  d0, d1 = [d0, d1].compact.map(&:to_date) if [d0, d1].map(&:class).uniq.size > 1
  raise OptionError, "Since date must be before until date" if d0 && d1 && d0 > d1

  links = @conditions[:links]
  if links.include?(true) && links.uniq.size > 1
    links.delete(true)
    overrides = result.select{ |it| it.label == "links" && !it.value.nil? }.map{ "#{it._name} #{it.value}" }
    $stderr.puts "Warning: ignoring #{result[:links]._name}; overriden by #{overrides.join(', ')}"
  end

  if @capture
    *pats, @capture_rx = @conditions[:message]
    @link_capture = !@capture_rx && @capture == '\0' && @conditions[:links].any? # no msg pats, argless -o, -L or friends
    raise OptionError, "#{result[:capture]._name} requires a message pattern" unless @capture_rx || @link_capture
    $stderr.puts "Warning: #{result[:capture]._name} used with multiple message patterns. Will use last given" unless pats.empty?
  end

  if @conditions.values.all?(&:empty?) && !@allow_all
    raise OptionError, "No filter conditions given. Use --all to allow, or see --help"
  end

################################################################################
### build sql query ############################################################
################################################################################

  def match(x, r) = "#{x} REGEXP '#{SQLite3::Database.quote r.to_s}'"
  def match_searchable(x, r) = "EXISTS (SELECT 1 FROM json_each(#{x}) WHERE #{match(:value, r)})"

  sql_cond = @conditions.map do |key, conds|
    next if conds.empty?
    conds.map do |value|
      cond = case [key, value]
      in :since, _             then date_cmp(:>=, value)
      in :until, _             then date_cmp(:<=, value)
      in :from_me, cond        then "is_from_me IS #{cond}"
      in :links, true          then "link_url IS NOT NULL"
      in :links, :youtube      then match(:link_url, %r[\Ahttps?://((www\.)?youtube\.com|youtu\.be)/]i)
      in :links, :soundcloud   then match(:link_url, %r[\Ahttps?://(on\.)?soundcloud\.com/]i)
      in :links, :twitter      then match(:link_url, %r[\Ahttps?://(pic\.)?(twitter|x)\.com/]i)
      in :links, String        then match(:link_url, mk_regexp(value))
      in :from,    Regexp      then match_searchable(:sender_searchable, value)
      in :to,      Regexp      then match_searchable(:recipients_searchable, value)
      in :with,    Regexp      then match_searchable(:members_searchable, value)
      in :chat,    Regexp      then match(:chat_name, value)
      in :message, Regexp      then match(:text, value)
      end
      [key, "(#{cond})"]
    end.group_by(&:first).transform_values{ it.map(&:last) }.map do |key, conds|
      op = key == :links ? "OR" : "AND"
      conds.join(" #{op} \n")
    end.join
  end.compact.map{ "(#{it})" }.join(" AND \n")

  limit = "LIMIT #{@limit}" if @limit
  time_col = @utc ? :utc_time : :local_time
  sql = <<~SQL
    SELECT
      -- message_id,
      payload_json,
      guid,
      has_attachments,
      sender_name as "from",
      recipient_names as "to",
      is_group_chat,
      chat_name,
      text,
      link_url,
      utc_time,
      #{time_col} as time
    FROM message_view
    #{'WHERE ' + sql_cond unless sql_cond.empty?}
    ORDER BY unix_time #{@reverse ? 'ASC' : 'DESC'}
    #{limit}
  SQL
  IO.popen(['bat', '-l', 'sql'], 'w') { it << sql } if @debug

  Messages.init
  found = Messages.db.select_hashes(sql)

################################################################################
### Massage results ############################################################
################################################################################

  found.each do |msg|
    msg[:from]        ||= "me"
    msg[:to]            = JSON.parse(msg[:to] || '["me"]')
    msg[:payload]       = JSON.parse(msg.delete(:payload_json) || "null")
    msg[:is_group_chat] = msg[:is_group_chat] == 1

  end

  if @json
    puts JSON.pretty_generate found
    exit
  end

  def R(...) = Rainbow(...)

  for msg in found
    msg => guid:, from:, to:, chat_name:, text:, link_url:, time:, is_group_chat:, has_attachments:, payload:

    if @link_capture
      text = link_url
    elsif @capture
      match = text.match @capture_rx
      text = @capture.gsub(/\\(\d)/){ match[$1.to_i] }
    end

    text = text.to_s
    text = link_url if text.empty? && link_url

    highlight_conds = @conditions[:message]
    link_urls = [payload&.dig(*%w[richLinkMetadata originalURL]), link_url] if link_url
    highlight = [*link_urls&.map{ Regexp.escape it if it }, *highlight_conds].compact
    text = text.gsub(/#{highlight.join(?|)}/) do
      if link_urls&.include?($&) # highlight match text inside link url
        open, close = R(?|).green.split(?|) # bit of a kludge but works
        open + $&.gsub(/#{highlight_conds.join ?|}/){ close + R($&).bright.green + open } + close
      else
        R($&).magenta.bright
      end
    end if highlight.any?

    text = text.gsub(/\R/, " ") if @one_line
    text = R("[attachments]").cyan if text =~ /\A\uFFFC*\z/ && has_attachments

    if @one_line && !@msg_only
      out = "#{R(time).bright.blue} [#{R(from).yellow} -> #{R(chat_name.to_s.empty? ? to*', ' : chat_name).yellow.bright}]: #{R(text)}" unless @msg_only
    elsif @msg_only
      out = text
    else
      out = {
        GUID: (guid if @debug),
        From: from,
        To: (to*', ' unless is_group_chat),
        With: (to*', ' if is_group_chat),
        Chat: chat_name,
        Date: time
      }.reject{|k,v| v.to_s.empty? }.map{|k,v| "#{R(k.to_s).yellow}: #{R(v).bright.yellow}" }.join("\n")
      out << "\n" << text
      summary = payload&.dig(*%w[ richLinkMetadata summary ])
      out << "\n\n" << R(summary.gsub(/^/, "  ")).cyan if summary
      out << "\n\n"
    end

    puts out
  end

rescue OptionError => e
  $stderr.puts e.message
  $stderr.puts "See --help for usage information"
  exit 1
end

# MISSING:
# -a
#     -R, --reset            Clear and rebuild cache

# Output formatting:
#     -m, --message-only     Only print message text
#     -1, --one-line         [from -> to] message, newlines removed
#     -j, --json             JSON output
#     -p, --payload          Include payload in JSON
#     -V, --reverse          Reverse order of output (oldest first)


__END__
Usage: PROG [options ...] [PATTERN ...]

Date filtering:
    -d, --since DATE       Match after DATE
    -u, --until DATE       Match before DATE
    -Z, --utc              Parse and print dates as UTC

Participant filtering:
    -t, --to CONTACT       Match recipients
    -f, --from CONTACT     Match sender
    -w, --with CONTACT     Match sender or recipients
    -c, --chat PATTERN     Match chat name

Match handling:
    -n, --max=NUM          Only print top NUM messages
    -C, --smart-case       Case-sensitive only when pattern has uppercase
                           letters. (default, turn off with -i or -I)
    -i, --ignore-case      Case-insensitive matches
    -I, --no-ignore-case   Case-sensitive matches
    -l, --literal          Literal string match, no regex
    -x, --regexp           Regexp match (default, turn off with -l)
    -a, --all              Allow calling with no conditions
                           (will print every message unless -n)

Message filtering:
    -s, --sent             Only match sent
    -r, --received         Only match received
    -L, --links[=URL]      Find links
    -Y, --youtube          Find youtube links
    -S, --soundcloud       Find soundcloud links
    -X, --twitter          Find twitter links

Output formatting:
    --[no-]color           Enable/disable color output
                           (default: yes if tty)
    -o, --capture [EXPR]   Print only $& or EXPR
    -m, --message-only     Only print message text
    -1, --one-line         [from -> to] message, newlines removed
    -j, --json             JSON output
    -P, --payload          Include payload in JSON
    -V, --reverse          Reverse sort order (oldest first)

Other:
    -R, --reset            Clear and rebuild cache
    -h, --help             Show this help


-- TODO: split marker. -h shows above, --help adds below.

DATE must be in ISO8601 format. Time and TZ optional.
You can use gdate for calculations: -d `gdate -Im -d -7days`
Dates are consdered local unless -Z or TZ component present in string.

PATTERN is a regular expression (onigmo).
Case-insensitive by default, unless upcase letters present.
Can force senitivity with '(?-i:pattern)'
Use -l to match literal string.

CONTACT works the same as pattern but matches a contact.
You can give part of a name, phone number, email. It'll look up
the full contact details in the address book and match against every
handle available for every matched contact.

--capture EXPR
When omitted, the entire match is presented.
When a number, that capture group is presented.
When a format string: "foo $1 bar $2", interpolates the captures.
-o same as -o"$&"
-o1 same as -o"$1"
--o "$3, $2"
Only works if single pattern given

-l,-x only affect subsequent patterns.

can use -x -to a.aa -l -to bbbb

-f a -f b is OR, ie, same opts combine as or. diff opts genereally combine as AND


Examples:
  PROG pattern                   # Basic search
  PROG -f Alice pattern          # From Alice
  PROG -d 2024-01-01 pattern    # Since date
  PROG -o '1,2' '(\w+):(\d+)'   # Capture groups
