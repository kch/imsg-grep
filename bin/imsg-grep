#!/usr/bin/env ruby
# frozen_string_literal: true
# Search and filter iMessage database entries with regex patterns, date ranges, and participant filters

require "bundler/setup"

require "date"
require "json"
require "sqlite3"
require "rainbow"
require "io/console"
require "strop"

require_relative "../lib/grep/date"
require_relative "../lib/grep/strop_utils"
require_relative "../lib/dev/print_query"

require_relative "../lib/messages"


include Strop::Exports

### initial values and defaults
@utc = false
@case = :smart
@mode = :regexp
@exact = false
@negate = false
@conditions = []

class << @conditions
  def [](group, ...) = Symbol===group ? filter_map{|k,c,*| c if k == group } : super
  def tuples(group)  = filter_map{|k, *xs| xs if k == group }
end

### tiny helpers

def consume(ivarname) = instance_variable_get(ivarname).tap{ instance_variable_set(ivarname, false) }

# wrap and indent text, respecting SGR sequences; only if tty
def wrap(s, indent=0, maxw = IO.console.winsize[1] - 2, disable: !$stdout.tty?)
  return s if disable
  sgr = /\e\[[\d;]*m/
  pad = " " * indent
  s.lines.map(&:chomp).each_with_object([]) do |line, acc|
    until line.empty?
      break acc << pad+line if line =~ %r[^#{sgr}*https?://\S+\z] # don't wrap link lines
      w = maxw - indent
      line.scan(sgr) { $~.begin(0) > w ? break : w += it.bytesize } # increase w to account for SGR
      ix = (line.rindex(" ", w) || w-1 if line.size > w)            # find last space before w, or use w, or nil when short enough
      acc << pad + line.slice!(..ix).chomp(" ")
    end
  end*?\n
end

def warn!(s) = $stderr.puts("Warning: #{s}")

def R(...) = Rainbow(...)

################################################################################
### parse helpers ##############################################################
################################################################################

def parse_date(str, utc = @utc)
  DateArg.parse(str, utc)
rescue DateArg::Error
  raise OptionError, "Invalid date #{str}; Use YYYY-MM-DD, or relative dates: 1y4m2d; See --help-dates"
end

def parse_p_int(str)
  Integer(str).tap{ raise ArgumentError unless it > 0 }
rescue ArgumentError
  raise OptionError, "#{str} not a positive integer"
end

def parse_capture(str)
  case str
  when nil            then '\0'
  when /\A\d(,\d)*\z/ then str.gsub(/(?=\d)/, ?\\).gsub(",", " ") # 1 or 1,2; "1,2" => "$1 $2"; 0 == $&
  when /\$[&\d]/      then str.gsub(?$, ?\\)
  else raise OptionError, "Invalid capture format: #{str}. Use '1,2' or '$1 $2'"
  end
end

# LIKE is too much of a mess. ASCII-insensitive, only sensitive option is GLOB.
# We'll be regexing everything, even literals, at maybe some perf cost.
def mk_regexp(pattern)
  case_ = @case
  case_ = /\p{Upper}/ =~ pattern ? :sensitive : :ignore if case_ == :smart
  pattern = Regexp.escape(pattern) if @mode == :literal
  pattern = "\\A#{pattern}\\z" if consume :@exact
  flags = [Regexp::IGNORECASE] if case_ == :ignore
  Regexp.new(pattern, *flags)
rescue RegexpError => e
  raise OptionError, "Invalid regular expression (#{pattern}): #{e.message}"
end

def add_cond(key, value, negate: false)
  @conditions << [key, value, negate]
end

################################################################################
### begin option parsing #######################################################
################################################################################
begin
  def read_base(f) = IO.read(__dir__ + "/../#{f}")
  HELP = read_base("HELP").gsub("PROG", File.basename($0))
  optlist = Strop.parse_help HELP[/.*~~/m]
  optlist << Optdecl[:D, :debug] # hidden opt
  optlist << Optdecl[:opts] # dev opt
  result = Strop.parse optlist

  capture_opts = %w[ capture ]
  text_opts    = %w[ no-meta one-line ]
  json_opts    = %w[ json payload ]
  result.exclusive json_opts, text_opts
  result.exclusive json_opts, capture_opts
  result.exclusive "sent", "received"
  result.compact_singles! %w[ max capture since until ]

  for opt in result
    case opt
    in Sep # ignore; `arg:` will handle .rest just fine
    in label: "since", value:    then add_cond :since, parse_date(value)
    in label: "until", value:    then add_cond :until, parse_date(value)
    in label: "to", value:       then add_cond :to,    mk_regexp(value), negate: consume(:@negate)
    in label: "from", value:     then add_cond :from,  mk_regexp(value), negate: consume(:@negate)
    in label: "with", value:     then add_cond :with,  mk_regexp(value), negate: consume(:@negate)
    in label: "chat", value:     then add_cond :chat,  mk_regexp(value), negate: consume(:@negate)
    in label: "smart-case"       then @case = :smart
    in label: "ignore-case"      then @case = :ignore
    in label: "no-ignore-case"   then @case = :sensitive
    in label: "literal"          then @mode = :literal
    in label: "regexp"           then @mode = :regexp
    in label: "invert-match"     then @negate = true
    in label: "exact"            then @exact = opt
    in label: "max", value:      then @limit = parse_p_int(value); @allow_all = true
    in label: "all"              then @allow_all = true
    in label: "sent"             then add_cond :from_me, true
    in label: "received"         then add_cond :from_me, false
    in label: "links", value:nil then add_cond :links, true
    in label: "links", value:    then add_cond :links, mk_regexp(value), negate: consume(:@negate)
    in label: "youtube"          then add_cond :links, :youtube
    in label: "soundcloud"       then add_cond :links, :soundcloud
    in label: "twitter"          then add_cond :links, :twitter
    in label: "capture", value:  then @capture = parse_capture(value)
    in label: "urls"             then @capture_link = true
    in label: "no-meta"          then @no_meta = true
    in label: "one-line"         then @one_line = true
    in label: "json"             then @json = true
    in label: "payload"          then @json = true, @payload = true
    in label: "reverse"          then @reverse = true
    in label: "color"            then Rainbow.enabled = opt.yes?
    in label: "utc"              then @utc = true
    in label: "help"             then puts HELP; exit
    in label: "help-dates"       then puts read_base("HELP_DATES"); exit
    in label: "debug"            then @debug = true

    in arg:
      eopt = consume :@exact and warn! "dropped #{eopt._name} used before message pattern."
      add_cond :message, mk_regexp(arg), negate: consume(:@negate)

    in label: "reset"
      Messages.reset_cache
      exit if (result.opts.map(&:label) - ["reset"]).empty? && result.args.empty? # exit if opt used alone

    # dev stuff: Used to see what options are still available
    in label: "opts"
      chars = (?0..?z).to_a.grep(/[^\W_]/).map{|c| [c] << R(c).then{ optlist[c]&.label ? it.black.bright : it.green.bright }}
      puts chars.map(&:last).join(" ")
      puts
      longs = chars.map{|c, cc| l = optlist[c]&.label; [R("-").black.bright, cc, R((" --#{l}" if l)).blue].join }
      per_col = 16
      longs.fill("", longs.length...((longs.length + per_col - 1) / per_col * per_col)) # fill to multiple for transpose
      w = longs.map(&:size).max + 4
      puts longs.map{ "%-#{w}s" % it }.each_slice(per_col).to_a.transpose.map(&:join).join("\n")
      exit
    end
  end

################################################################################
### checking conflicting options ###############################################
################################################################################

  if @conditions.empty? && !@allow_all
    raise OptionError, "No filter conditions given. Use --all to allow, or see --help"
  end

  # find date conflicts: since > until
  # Time<=>Date would fail compare below, so we lose precision to make it work (
  # in most cases, without doing a lot of work. Worst case, empty results.
  # fine to convert as these values are only use for this check
  d0, d1 = @conditions[:since].last, @conditions[:until].last
  d0, d1 = [d0, d1].compact.map(&:to_date) if [d0, d1].map(&:class).uniq.size > 1
  raise OptionError, "Since date must be before until date" if d0 && d1 && d0 > d1

  # ignore request for all links when already getting more specific site links
  # -L(noarg) + -[YSX]|Larg, drops -L
  links = @conditions[:links]
  if links.include?(true) && links.uniq.size > 1
    links.delete(true)
    overrides = result.opts.select do
      site_link = %w[ youtube soundcloud twitter ].include?(it.label)
      pat_link = it.label == "links" && !it.value.nil?
      site_link || pat_link
    end.map{ "#{it._name} #{it.value}" }
    warn! "ignoring #{result[:links]._name}; overriden by #{overrides.join(', ')}"
  end

  # require mag pattern for -o
  # warn -o with multiple msg patterns
  # ignore -v patterns
  if @capture
    *pats, @capture_pat = @conditions.tuples(:message).filter_map{|c,negate| c unless negate }  # take last pattern for capture refs, rest for warn
    raise OptionError, "#{result[:capture]._name} requires a message pattern" unless @capture_pat
    warn! "#{result[:capture]._name} used with multiple message patterns. Will capture from last." unless pats.empty?
  end

################################################################################
### build sql query ############################################################
################################################################################

  def date_cmp(op, dt)
    case [dt, @utc]
    in Date, true  then "utc_date   #{op} '#{dt.strftime('%Y-%m-%d')}'"
    in Date, false then "local_date #{op} '#{dt.strftime('%Y-%m-%d')}'"
    in Time, _     then "unix_time  #{op} #{dt.to_i}"
    end
  end

  def match(x, r) = "#{x} REGEXP '#{SQLite3::Database.quote r.to_s}'"
  def match_searchable(x, r) = "EXISTS (SELECT 1 FROM json_each(#{x}) WHERE #{match(:value, r)})"

  sql_cond = @conditions.group_by(&:first).map do |key, conds|
    conds = conds.map do |_, value, negate|
      sql = case [key, value]
      in :since,   _           then date_cmp(:>=, value)
      in :until,   _           then date_cmp(:<=, value)
      in :from_me, _           then "is_from_me IS #{value}"
      in :links, true          then "link IS NOT NULL"
      in :links, :youtube      then match(:link, %r["https?://((www\.)?youtube\.com|youtu\.be)/]i) # matching inside json, " acts as \A sort of
      in :links, :soundcloud   then match(:link, %r["https?://(on\.)?soundcloud\.com/]i)
      in :links, :twitter      then match(:link, %r["https?://(pic\.)?(twitter|x)\.com/]i)
      in :links,   Regexp      then match(:link, value)
      in :from,    Regexp      then match_searchable(:sender_searchable, value)
      in :to,      Regexp      then match_searchable(:recipients_searchable, value)
      in :with,    Regexp      then match_searchable(:members_searchable, value)
      in :chat,    Regexp      then match(:chat_name, value)
      in :message, Regexp      then match(:text, value)
      end
      sql = "NOT #{sql}" if negate
      sql
    end
    op = key == :links ? "OR" : "AND"
    ?( + conds * " #{op} \n" + ?)
  end.join(" AND \n")

  limit = "LIMIT #{@limit}" if @limit
  time_col = @utc ? :utc_time : :local_time
  sql = <<~SQL
    SELECT
      #{'payload_json,' if @payload}
      guid,
      has_attachments,
      sender_name as "from",
      recipient_names as "to",
      is_group_chat,
      chat_name,
      text,
      link,
      utc_time,
      #{time_col} as time
    FROM message_view
    #{'WHERE ' + sql_cond unless sql_cond.empty?}
    ORDER BY unix_time #{@reverse ? 'ASC' : 'DESC'}
    #{limit}
  SQL

  if @debug
    bat = `hash bat 2>/dev/null` && $?.success? ? ["bat", '-l', 'sql'] : "cat"
    IO.popen(bat, 'w', out: :err) { it << sql }
  end

  Messages.init
  found = Messages.db.select_hashes(sql)

################################################################################
### Massage results ############################################################
################################################################################

  found.each do |msg|
    msg[:from]        ||= "me"
    msg[:to]            = JSON.parse(msg[:to] || '["me"]')
    msg[:link]          = JSON.parse(msg[:link] || "null")&.transform_keys(&:to_sym)
    msg[:payload]       = JSON.parse(msg.delete(:payload_json) || "null") if msg.key? :payload_json
    msg[:is_group_chat] = msg[:is_group_chat] == 1
  end

  if @json
    puts JSON.pretty_generate found
    exit
  end

  class String
    # 'xxx'.cleave(nil) # => %w[ xxx ]
    # 'a1b2c3d'.cleave(/\d/) # => %w[ a 1 b 2 c 3 d ]
    # (cant use split(/(...)/) bc inner regexen may have captures)
    def cleave(rx, &)
      return [self] unless rx
      r, i = [], 0
      scan(rx) { r << self[i...$~.begin(0)] << $&; i = $~.end(0) }
      r << self[i..]
    end
  end

  # stylesheets :P
  c = Object.new
  def c.link(s)         = R(s).green
  def c.link!(s)        = R(s).green.bright
  def c.match!(s)       = R(s).magenta.bright
  def c.capture!(s)     = R(s).red.bright
  def c.attachs(s)      = R(s).cyan
  def c.l_time(s)       = R(s).bright.blue
  def c.l_from(s)       = R(s).yellow
  def c.l_to(s)         = R(s).yellow.bright
  def c.label(s)        = R(s).yellow
  def c.value(s)        = R(s).yellow.bright
  def c.link_title(s)   = R(s).cyan.bright
  def c.link_summary(s) = R(s).cyan

  # to highlight all matches in text, inside links
  rx_highlight       = /#{@conditions[:message]*?|}/ if @conditions[:message].any?
  rx_links           = @conditions[:links].select{ Regexp===it }
  rx_link_highlights = [*rx_links, rx_highlight].compact
  rx_link_highlights = (/#{rx_link_highlights*?|}/ if rx_link_highlights.any?)

  def highlight(s, r, a, b)
    return unless s
    s.cleave(r).each_slice(2).flat_map do |sa, sb|
      [ (a.(sa) if sa && !sa.empty?),
        (b.(sb) if sb && !sb.empty?)]
    end.join
  end

  for msg in found
    msg => guid:, from:, to:, chat_name:, text:, link:, time:, is_group_chat:, has_attachments:

    # highlight matches inside urls
    url,  ourl  = link&.values_at(:url, :original_url)
    curl, courl = [url, ourl].map { highlight(it, rx_link_highlights, ->a{c.link a}, ->b{c.link! b}) }

    text = text.to_s.dup
    if @capture_link && url  # captured links replace text
      text = curl
    elsif @capture    # replace text with eval'd capture output string
      match = @capture_pat.match text
      text  = @capture.gsub(/\\(\d)/){ c.capture! match[$1.to_i] }
    else
      rx_links = (/#{[ourl, url].compact.map{Regexp.escape it}*?|}/ if link)
      has_link = link && text =~ rx_links
      # hightlight matches in text, first replacing links with colored versions from above
      text = text.cleave(rx_links).each_slice(2).flat_map do |s, u|
        msg_text = highlight(s, rx_highlight, ->a{a}, ->b{c.match! b}) # hilight the message part that is not link
        msg_url  = { ourl => courl, url => curl}[u]                    # urls highlighted earlier, use that
        [msg_text, msg_url]
      end.join
      # append whole url if not fully present in text (missing protocol etc)
      text << "\n\n" << curl if link && !has_link
    end

    text = text.gsub(/\p{Space}*\R\p{Space}*/, " ").strip if @one_line
    text = c.attachs("[attachments]") if has_attachments && text =~ /\A\uFFFC*\z/ # if text is empty or only object marker

    if @no_meta # oneline included, already onelined above
      puts text
    elsif @one_line
      to = chat_name.to_s.empty? ? to*', ' : chat_name
      puts "#{c.l_time time} [#{c.l_from from} -> #{c.l_to to}]: #{text}"
    else
      nn      = "\n\n"
      title   = link&.dig :title
      summary = link&.dig :summary
      out = {
        GUID: (guid if @debug),
        From: from,
        "To..": (to*', ' unless is_group_chat),
        With:   (to*', ' if is_group_chat),
        Chat: chat_name,
        Date: time
      }.reject{|k,v| v.to_s.empty? }.map{|k,v| "#{c.label k}: #{c.value v}" }*?\n
      out << nn << wrap(text, 2)
      out << nn << c.link_title(wrap(title, 2)) if title
      out << nn << c.link_summary(wrap(summary, 2)) if summary
      out << nn
      puts out
    end

  end

rescue OptionError => e
  $stderr.puts "Error: " + e.message
  $stderr.puts "See --help for usage information"
  exit 1
end
