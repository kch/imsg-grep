#!/usr/bin/swift
import SQLite3
import Foundation
import ObjectiveC

// MARK: - Command Line Args
let args = CommandLine.arguments.dropFirst()
var useRawLike = false
var contentPattern: String = ""
var since: String?
var to: String?
var from: String?
var with: String?
var sender: String?
var chat: String?

var i = args.startIndex
while i < args.endIndex {
    switch args[i] {
    case "--since":  i += 1; since  = i < args.endIndex ? args[i] : nil
    case "--to":     i += 1; to     = i < args.endIndex ? args[i] : nil
    case "--from":   i += 1; from   = i < args.endIndex ? args[i] : nil
    case "--with":   i += 1; with   = i < args.endIndex ? args[i] : nil
    case "--sender": i += 1; sender = i < args.endIndex ? args[i] : nil
    case "--chat":   i += 1; chat   = i < args.endIndex ? args[i] : nil
    case "--raw":   useRawLike = true
    default: contentPattern = args[i]
    }
    i += 1
}

if contentPattern.isEmpty {
    fputs("Usage: imsg-grep [--flag value] pattern\n", stderr)
    exit(1)
}

// MARK: - SQLite Function Setup
let searchPattern = useRawLike ?
    "%\(contentPattern.lowercased())%" :
    contentPattern
let NSUnarchiver: AnyClass = NSClassFromString("NSUnarchiver")!
let sel            = NSSelectorFromString("unarchiveObjectWithData:")
let imp            = NSUnarchiver.method(for: sel)
let unarchive     = unsafeBitCast(imp, to: (@convention(c) (AnyClass, Selector, NSData) -> NSAttributedString?).self)
let SQLITE_TRANSIENT = unsafeBitCast(-1, to: sqlite3_destructor_type.self)

// Track query parameters
struct QueryParams {
    var params: [String] = []
    mutating func add(_ value: String) {
        params.append(value)
    }
}

// Setup regexp and attributed text decoding functions
func setupSQLiteFunctions(db: OpaquePointer, pattern: String) {
    // Compile regex once
    guard let compiledRegex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive) else {
        fputs("Invalid regex pattern\n", stderr)
        exit(1)
    }

    // Store regex in user context
    let context = Unmanaged.passRetained(compiledRegex)
    // fputs("Setting up SQLite functions...\n", stderr)

    // Regular expression matching
    sqlite3_create_function(
    db,
    "REGEXP",
    2,
    SQLITE_UTF8 | SQLITE_DETERMINISTIC,
    context.toOpaque(),
    { context, argc, argv in
    guard let text = sqlite3_value_text(argv?[1]) else {
        sqlite3_result_int(context, 0)
        return
    }
    let regex = Unmanaged<NSRegularExpression>.fromOpaque(
        sqlite3_user_data(context)).takeUnretainedValue()
    let nsString = String(cString: text)
    let range = NSRange(nsString.startIndex..<nsString.endIndex, in: nsString)
    let matches = regex.firstMatch(in: nsString, range: range) != nil
    sqlite3_result_int(context, matches ? 1 : 0)
    },
        nil,
        nil
    )

    // Attributed text decoder with proper string handling
    sqlite3_create_function(
        db,
        "DECODE_ATTRIBUTED",
        1,
        SQLITE_UTF8 | SQLITE_DETERMINISTIC,
        nil,
        { context, argc, argv in
            guard let data = sqlite3_value_blob(argv?[0]) else {
                sqlite3_result_null(context)
                return
            }
            let length = Int(sqlite3_value_bytes(argv?[0]))
            let bytes = Data(bytes: data, count: length) as NSData
            if let str = unarchive(NSUnarchiver, sel, bytes)?.string {
                str.withCString {
                    sqlite3_result_text(context, $0, -1, SQLITE_TRANSIENT)
                }
            } else {
                sqlite3_result_null(context)
            }
        },
        nil,
        nil
    )
}

// MARK: - Query Building
func buildQuery() -> (String, [String]) {
    var conditions = [String]()
    var params = QueryParams()

    // Base query using CTE for efficient text decoding
    var baseQuery = """
        WITH decoded AS (
            SELECT *,
                   DECODE_ATTRIBUTED(attributedBody) as decoded_text,
                   CASE
                   WHEN \(useRawLike ? "LOWER(text) LIKE ?" : "text REGEXP ?") THEN 'text'
                     ELSE 'attr'
                   END as matched_in
            FROM message
            -- Main content matching conditions
            WHERE (\(useRawLike ? "LOWER(text) LIKE ?" : "text REGEXP ?")
                  OR (attributedBody IS NOT NULL
                      AND length(attributedBody) > 0
                      AND \(useRawLike ? "LOWER(DECODE_ATTRIBUTED(attributedBody)) LIKE ?" : "DECODE_ATTRIBUTED(attributedBody) REGEXP ?")))
            -- Exclude metadata/action messages:
            -- associated_message_type: reaction
            -- 2000: love
            -- 2001: like
            -- 2002: dislike
            -- 2003: laugh
            -- 2004: emphasize
            -- 2005: question
            -- 3000+, 4000 found as well
            AND (associated_message_type IS NULL
                 OR associated_message_type < 2000)
        )
        SELECT
            datetime((decoded.date / 1000000000) + 978307200, 'unixepoch', 'localtime') as date,
            COALESCE(handle.id, '')                           as sender,
            COALESCE(handle.service, '')                      as service,
            chat.style                                        as chat_style,
            chat.display_name                                 as chat_name,
            GROUP_CONCAT(DISTINCT other_handles.id)           as participants,
            decoded.text,
            decoded.decoded_text,
            decoded.matched_in,
            decoded.cache_has_attachments
        FROM decoded
            LEFT JOIN handle ON decoded.handle_id = handle.ROWID
            LEFT JOIN chat_message_join ON decoded.ROWID = chat_message_join.message_id
            LEFT JOIN chat ON chat_message_join.chat_id = chat.ROWID
            LEFT JOIN chat_handle_join ON chat.ROWID = chat_handle_join.chat_id
            LEFT JOIN handle other_handles ON chat_handle_join.handle_id = other_handles.ROWID
        """

    // Add pattern parameters for both text and attributed content
    params.add(searchPattern)
    params.add(searchPattern)
    params.add(searchPattern)

    // Additional search conditions
    if let since = since {
        conditions.append("datetime(decoded.date / 1000000000 + 978307200, 'unixepoch') >= datetime(?)")
        params.add(since)
    }

    if let to = to {
        conditions.append("""
            (chat.display_name REGEXP ? OR
             EXISTS (
                 SELECT 1 FROM chat_handle_join chj
                 JOIN handle h ON chj.handle_id = h.ROWID
                 WHERE chj.chat_id = chat.ROWID AND h.id REGEXP ?
             ))
            """)
        params.add(to)
        params.add(to)
    }

    if let sender = sender {
        conditions.append("handle.id REGEXP ?")
        params.add(sender)
    }

    if let chat = chat {
        conditions.append("chat.display_name REGEXP ?")
        params.add(chat)
    }

    if !conditions.isEmpty {
        baseQuery += " WHERE " + conditions.joined(separator: " AND ")
    }

    baseQuery += """

        GROUP BY decoded.ROWID
        ORDER BY decoded.date DESC
        """

    return (baseQuery, params.params)
}

// MARK: - Message Processing
func processMessage(statement: OpaquePointer, index: Int) -> String {
    let date         = sqlite3_column_text(statement, 0).map { String(cString: $0) } ?? ""
    let sender       = sqlite3_column_text(statement, 1).map { String(cString: $0) } ?? ""
    let service      = sqlite3_column_text(statement, 2).map { String(cString: $0) } ?? ""
    let chatStyle    = sqlite3_column_int(statement, 3)
    let chatName     = sqlite3_column_text(statement, 4).map { String(cString: $0) }
    let participants = sqlite3_column_text(statement, 5).map { String(cString: $0) }
    let text         = sqlite3_column_text(statement, 6).map { String(cString: $0) }
    let decodedText  = sqlite3_column_text(statement, 7).map { String(cString: $0) }
    let matchedIn    = sqlite3_column_text(statement, 8).map { String(cString: $0) }
    let hasAttachments = sqlite3_column_int(statement, 9) == 1

    let messageText: String
    let textAlert: String
    if let t = text, let dt = decodedText {
        if t == dt {
            messageText = t
            textAlert = ""
        } else {
            messageText = "TEXT: \(t)\nATTR: \(dt)"
            textAlert = "[!] Different text versions"
        }
    } else {
        messageText = text ?? decodedText ?? ""
        textAlert = ""
    }

    let chatType = chatStyle == 43 ? "Group" : "Individual"

    return """
        [\(index)] \(date) \(textAlert)
        From:         \(sender)
        Service:      \(service)
        Chat Type:    \(chatType)
        Chat Name:    \(chatName ?? "none")
        Participants: \(participants ?? "none")
        Message:      \(messageText)
        Matched In:   \(matchedIn ?? "unknown")
        Attachments:  \(hasAttachments)
        ----------------
        """
}

// MARK: - Main Run
let homePath = NSString(string: "~/Library/Messages/chat.db").expandingTildeInPath
var db: OpaquePointer?

guard sqlite3_open(homePath, &db) == SQLITE_OK,
      let db = db else {
    fputs("Cannot open database\n", stderr)
    exit(1)
}
defer { sqlite3_close(db) }

setupSQLiteFunctions(db: db, pattern: contentPattern)

let (query, params) = buildQuery()
// fputs("\nQuery:\n\(query)\n", stderr)
// fputs("\nParameters: \(params)\n", stderr)

var statement: OpaquePointer?
guard sqlite3_prepare_v2(db, query, -1, &statement, nil) == SQLITE_OK else {
    fputs("Cannot prepare statement: \(String(cString: sqlite3_errmsg(db)))\n", stderr)
    exit(1)
}
defer { sqlite3_finalize(statement) }

for (index, param) in params.enumerated() {
    let idx = Int32(index + 1)
    // fputs("Binding param[\(idx)]: \(param)\n", stderr)
    param.withCString { cstr in
        let result = sqlite3_bind_text(statement, idx, cstr, -1, SQLITE_TRANSIENT)
        if result != SQLITE_OK {
            fputs("Failed to bind parameter \(idx): \(String(cString: sqlite3_errmsg(db)))\n", stderr)
        }
    }
}

var matchCount = 0
while sqlite3_step(statement) == SQLITE_ROW {
    matchCount += 1
    print(processMessage(statement: statement!, index: matchCount))
}

fputs("Found \(matchCount) matches\n", stderr)
